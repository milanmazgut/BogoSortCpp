#include <iostream>
#include <vector>
#include <thread>
#include <algorithm>
#include <random>
#include <chrono>
#include <atomic>
#include <numeric>
#include <sstream>



// Implementation of xoshiro256++ PRNG Generated by AI
class Xoshiro256PlusPlus {
public:
    Xoshiro256PlusPlus(uint64_t seed = 0) {
        state[0] = seed;
        state[1] = 0x9E3779B97F4A7C15;  
        state[2] = 0x6A09E667F3BCC908;  
        state[3] = 0xBB67AE8584CAA73B;  
    }

    uint64_t next() {
        const uint64_t result = rotl(state[0] + state[3], 23) + state[0];
        const uint64_t t = state[1] << 17;

        state[2] ^= state[0];
        state[3] ^= state[1];
        state[1] ^= state[2];
        state[0] ^= state[3];

        state[2] ^= t;
        state[3] = rotl(state[3], 45);

        return result;
    }

    uint64_t operator()() {
        return next();
    }

    static uint64_t min() {
        return std::numeric_limits<uint64_t>::min();
    }

    static uint64_t max() {
        return std::numeric_limits<uint64_t>::max();
    }

private:
    uint64_t state[4];

    static uint64_t rotl(const uint64_t x, int k) {
        return (x << k) | (x >> (64 - k));
    }
};

// Global stop flag when solution is found on any thread
std::atomic<bool> stop(false);

bool isSorted(const int arr[], int size) {
    for (int i = 0; i < size - 1; ++i) {
        if (arr[i] > arr[i + 1]) {
            return false;
        }
    }
    return true;
}


void customShuffle(int arr[], int size, Xoshiro256PlusPlus& rng) {
    for (int i = size - 1; i > 0; --i) {
        int j = rng() % (i + 1);
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}

void bogoSort(int arr[], int size) {
    int* arr_copy = new int[size];
    std::copy(arr, arr + size, arr_copy);

    int i = 0;
    std::random_device rd;
    Xoshiro256PlusPlus g(rd());

    auto start = std::chrono::high_resolution_clock::now();

    while (!stop) {
        ++i;
        customShuffle(arr_copy, size, g);
        if (isSorted(arr_copy, size)) {
            std::cout << "Sorted" << std::endl << "Iterations per thread: " << i << std::endl;
            break;
        }
    }
    if (!stop)
    {
        auto end = std::chrono::high_resolution_clock::now();
        std::chrono::duration<double> elapsed = end - start;
        std::cout << "Time: " << elapsed.count() << " seconds " << "Iterations per second by successfull thread: " << i / elapsed.count() << std::endl;
        stop = true;
    }
    


    delete[] arr_copy;
}



int main() {
	std::cout << "Welcome in \"fast\" BogoSort in C++" << std::endl;
    int num_cores = std::thread::hardware_concurrency();
    std::cout << "Number of avaliable CPU cores: " << num_cores << std::endl <<
        "How many would you like to use? (1-" << num_cores << ") ?" << std::endl;;
	int cores = 0;
    std::cin >> cores;
    while (cores < 1 || cores > num_cores) {
		std::cout << "Wrong value try again" << std::endl;
		std::cin >> cores;
    }
	const int num_threads = cores;
    
    std::cout << "Write your unsorted array in format: 5 3 7 1 4" << std::endl;

    std::string input;
	std::cin.ignore();
    std::getline(std::cin, input);

    std::stringstream ss(input);
    std::vector<int> numbers;
    int number;

    while (ss >> number) {
        numbers.push_back(number);
    }

    int numberOfDigits = numbers.size();
    int* array = new int[numberOfDigits];
    for (int i = 0; i < numberOfDigits; ++i) {
        array[i] = numbers[i];
    }

    std::vector<std::thread> threads;
    for (unsigned int i = 0; i < num_threads; ++i) {
        threads.emplace_back(bogoSort, array, numberOfDigits);
    }


    for (auto& thread : threads) {
        thread.join();
    }

    delete[] array;
    return 0;
}
